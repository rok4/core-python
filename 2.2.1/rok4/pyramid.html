<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.0">
<title>rok4.pyramid API documentation</title>
<meta name="description" content="Provide classes to use pyramid&#39;s data …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>rok4.pyramid</code></h1>
</header>
<section id="section-intro">
<p>Provide classes to use pyramid's data.</p>
<p>The module contains the following classes:</p>
<ul>
<li><code><a title="rok4.pyramid.Pyramid" href="#rok4.pyramid.Pyramid">Pyramid</a></code> - Data container</li>
<li><code><a title="rok4.pyramid.Level" href="#rok4.pyramid.Level">Level</a></code> - Level of a pyramid</li>
</ul>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="rok4.pyramid.ROK4_IMAGE_HEADER_SIZE"><code class="name">var <span class="ident">ROK4_IMAGE_HEADER_SIZE</span></code></dt>
<dd>
<div class="desc"><p>Slab's header size, 2048 bytes</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="rok4.pyramid.b36_number_decode"><code class="name flex">
<span>def <span class="ident">b36_number_decode</span></span>(<span>number: str) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Convert base-36 number to base-10</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>number</code></strong> :&ensp;<code>str</code></dt>
<dd>base-36 number</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>base-10 number</dd>
</dl></div>
</dd>
<dt id="rok4.pyramid.b36_number_encode"><code class="name flex">
<span>def <span class="ident">b36_number_encode</span></span>(<span>number: int) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Convert base-10 number to base-36</p>
<p>Used alphabet is '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>number</code></strong> :&ensp;<code>int</code></dt>
<dd>base-10 number</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>base-36 number</dd>
</dl></div>
</dd>
<dt id="rok4.pyramid.b36_path_decode"><code class="name flex">
<span>def <span class="ident">b36_path_decode</span></span>(<span>path: str) ‑> Tuple[int, int]</span>
</code></dt>
<dd>
<div class="desc"><p>Get slab's column and row from a base-36 based path</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>slab's path</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tuple[int, int]</code></dt>
<dd>slab's column and row</dd>
</dl></div>
</dd>
<dt id="rok4.pyramid.b36_path_encode"><code class="name flex">
<span>def <span class="ident">b36_path_encode</span></span>(<span>column: int, row: int, slashs: int) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Convert slab indices to base-36 based path, with .tif extension</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>column</code></strong> :&ensp;<code>int</code></dt>
<dd>slab's column</dd>
<dt><strong><code>row</code></strong> :&ensp;<code>int</code></dt>
<dd>slab's row</dd>
<dt><strong><code>slashs</code></strong> :&ensp;<code>int</code></dt>
<dd>slashs' number (to split path)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>base-36 based path</dd>
</dl></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="rok4.pyramid.Level"><code class="flex name class">
<span>class <span class="ident">Level</span></span>
</code></dt>
<dd>
<div class="desc"><p>A pyramid's level, raster or vector</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>__id</code></strong> :&ensp;<code>str</code></dt>
<dd>level's identifier. have to exist in the pyramid's used TMS</dd>
<dt><strong><code>__tile_limits</code></strong> :&ensp;<code>Dict[str, int]</code></dt>
<dd>minimum and maximum tiles' columns and rows of pyramid's content</dd>
<dt><strong><code>__slab_size</code></strong> :&ensp;<code>Tuple[int, int]</code></dt>
<dd>number of tile in a slab, widthwise and heightwise</dd>
<dt><strong><code>__tables</code></strong> :&ensp;<code>List[Dict]</code></dt>
<dd>for a VECTOR pyramid, description of vector content, tables and attributes</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Level:
    &#34;&#34;&#34;A pyramid&#39;s level, raster or vector

    Attributes:
        __id (str): level&#39;s identifier. have to exist in the pyramid&#39;s used TMS
        __tile_limits (Dict[str, int]): minimum and maximum tiles&#39; columns and rows of pyramid&#39;s content
        __slab_size (Tuple[int, int]): number of tile in a slab, widthwise and heightwise
        __tables (List[Dict]): for a VECTOR pyramid, description of vector content, tables and attributes
    &#34;&#34;&#34;

    @classmethod
    def from_descriptor(cls, data: Dict, pyramid: &#34;Pyramid&#34;) -&gt; &#34;Level&#34;:
        &#34;&#34;&#34;Create a pyramid&#39;s level from the pyramid&#39;s descriptor levels element

        Args:
            data (Dict): level&#39;s information from the pyramid&#39;s descriptor
            pyramid (Pyramid): pyramid containing the level to create

        Raises:
            Exception: different storage or masks presence between the level and the pyramid
            MissingAttributeError: Attribute is missing in the content

        Returns:
            Pyramid: a Level instance
        &#34;&#34;&#34;
        level = cls()

        level.__pyramid = pyramid

        # Attributs communs
        try:
            level.__id = data[&#34;id&#34;]
            level.__tile_limits = data[&#34;tile_limits&#34;]
            level.__slab_size = (
                data[&#34;tiles_per_width&#34;],
                data[&#34;tiles_per_height&#34;],
            )

            # Informations sur le stockage : on les valide et stocke dans la pyramide
            if pyramid.storage_type.name != data[&#34;storage&#34;][&#34;type&#34;]:
                raise Exception(
                    f&#34;Pyramid {pyramid.descriptor} owns levels using different storage types ({ data[&#39;storage&#39;][&#39;type&#39;] }) than its one ({pyramid.storage_type.name})&#34;
                )

            if pyramid.storage_type == StorageType.FILE:
                pyramid.storage_depth = data[&#34;storage&#34;][&#34;path_depth&#34;]

            if &#34;mask_directory&#34; in data[&#34;storage&#34;] or &#34;mask_prefix&#34; in data[&#34;storage&#34;]:
                if not pyramid.own_masks:
                    raise Exception(
                        f&#34;Pyramid {pyramid.__descriptor} does not define a mask format but level {level.__id} define mask storage informations&#34;
                    )
            else:
                if pyramid.own_masks:
                    raise Exception(
                        f&#34;Pyramid {pyramid.__descriptor} define a mask format but level {level.__id} does not define mask storage informations&#34;
                    )

        except KeyError as e:
            raise MissingAttributeError(pyramid.descriptor, f&#34;levels[].{e}&#34;)

        # Attributs dans le cas d&#39;un niveau vecteur
        if level.__pyramid.type == PyramidType.VECTOR:
            try:
                level.__tables = data[&#34;tables&#34;]

            except KeyError as e:
                raise MissingAttributeError(pyramid.descriptor, f&#34;levels[].{e}&#34;)

        return level

    @classmethod
    def from_other(cls, other: &#34;Level&#34;, pyramid: &#34;Pyramid&#34;) -&gt; &#34;Level&#34;:
        &#34;&#34;&#34;Create a pyramid&#39;s level from another one

        Args:
            other (Level): level to clone
            pyramid (Pyramid): new pyramid containing the new level

        Raises:
            Exception: different storage or masks presence between the level and the pyramid
            MissingAttributeError: Attribute is missing in the content

        Returns:
            Pyramid: a Level instance
        &#34;&#34;&#34;

        level = cls()

        # Attributs communs
        level.__id = other.__id
        level.__pyramid = pyramid
        level.__tile_limits = other.__tile_limits
        level.__slab_size = other.__slab_size

        # Attributs dans le cas d&#39;un niveau vecteur
        if level.__pyramid.type == PyramidType.VECTOR:
            level.__tables = other.__tables

        return level

    def __str__(self) -&gt; str:
        return f&#34;{self.__pyramid.type.name} pyramid&#39;s level &#39;{self.__id}&#39; ({self.__pyramid.storage_type.name} storage)&#34;

    @property
    def serializable(self) -&gt; Dict:
        &#34;&#34;&#34;Get the dict version of the pyramid object, pyramid&#39;s descriptor compliant

        Returns:
            Dict: pyramid&#39;s descriptor structured object description
        &#34;&#34;&#34;
        serialization = {
            &#34;id&#34;: self.__id,
            &#34;tiles_per_width&#34;: self.__slab_size[0],
            &#34;tiles_per_height&#34;: self.__slab_size[1],
            &#34;tile_limits&#34;: self.__tile_limits,
        }

        if self.__pyramid.type == PyramidType.VECTOR:
            serialization[&#34;tables&#34;] = self.__tables

        if self.__pyramid.storage_type == StorageType.FILE:
            serialization[&#34;storage&#34;] = {
                &#34;type&#34;: &#34;FILE&#34;,
                &#34;image_directory&#34;: f&#34;{self.__pyramid.name}/DATA/{self.__id}&#34;,
                &#34;path_depth&#34;: self.__pyramid.storage_depth,
            }
            if self.__pyramid.own_masks:
                serialization[&#34;storage&#34;][
                    &#34;mask_directory&#34;
                ] = f&#34;{self.__pyramid.name}/MASK/{self.__id}&#34;

        elif self.__pyramid.storage_type == StorageType.CEPH:
            serialization[&#34;storage&#34;] = {
                &#34;type&#34;: &#34;CEPH&#34;,
                &#34;image_prefix&#34;: f&#34;{self.__pyramid.name}/DATA_{self.__id}&#34;,
                &#34;pool_name&#34;: self.__pyramid.storage_root,
            }
            if self.__pyramid.own_masks:
                serialization[&#34;storage&#34;][&#34;mask_prefix&#34;] = f&#34;{self.__pyramid.name}/MASK_{self.__id}&#34;

        elif self.__pyramid.storage_type == StorageType.S3:
            serialization[&#34;storage&#34;] = {
                &#34;type&#34;: &#34;S3&#34;,
                &#34;image_prefix&#34;: f&#34;{self.__pyramid.name}/DATA_{self.__id}&#34;,
                &#34;bucket_name&#34;: self.__pyramid.storage_root,
            }
            if self.__pyramid.own_masks:
                serialization[&#34;storage&#34;][&#34;mask_prefix&#34;] = f&#34;{self.__pyramid.name}/MASK_{self.__id}&#34;

        return serialization

    @property
    def id(self) -&gt; str:
        return self.__id

    @property
    def bbox(self) -&gt; Tuple[float, float, float, float]:
        &#34;&#34;&#34;Return level extent, based on tile limits

        Returns:
            Tuple[float, float, float, float]: level terrain extent (xmin, ymin, xmax, ymax)
        &#34;&#34;&#34;

        min_bbox = self.__pyramid.tms.get_level(self.__id).tile_to_bbox(
            self.__tile_limits[&#34;min_col&#34;], self.__tile_limits[&#34;max_row&#34;]
        )
        max_bbox = self.__pyramid.tms.get_level(self.__id).tile_to_bbox(
            self.__tile_limits[&#34;max_col&#34;], self.__tile_limits[&#34;min_row&#34;]
        )

        return (min_bbox[0], min_bbox[1], max_bbox[2], max_bbox[3])

    @property
    def resolution(self) -&gt; str:
        return self.__pyramid.tms.get_level(self.__id).resolution

    @property
    def tile_matrix(self) -&gt; TileMatrix:
        return self.__pyramid.tms.get_level(self.__id)

    @property
    def slab_width(self) -&gt; int:
        return self.__slab_size[0]

    @property
    def slab_height(self) -&gt; int:
        return self.__slab_size[1]

    @property
    def tile_limits(self) -&gt; Dict[str, int]:
        return self.__tile_limits

    def is_in_limits(self, column: int, row: int) -&gt; bool:
        &#34;&#34;&#34;Is the tile indices in limits ?

        Args:
            column (int): tile&#39;s column
            row (int): tile&#39;s row

        Returns:
            bool: True if tiles&#39; limits contain the provided tile&#39;s indices
        &#34;&#34;&#34;
        return (
            self.__tile_limits[&#34;min_row&#34;] &lt;= row
            and self.__tile_limits[&#34;max_row&#34;] &gt;= row
            and self.__tile_limits[&#34;min_col&#34;] &lt;= column
            and self.__tile_limits[&#34;max_col&#34;] &gt;= column
        )

    def set_limits_from_bbox(self, bbox: Tuple[float, float, float, float]) -&gt; None:
        &#34;&#34;&#34;Set tile limits, based on provided bounding box

        Args:
            bbox (Tuple[float, float, float, float]): terrain extent (xmin, ymin, xmax, ymax), in TMS coordinates system

        &#34;&#34;&#34;

        col_min, row_min, col_max, row_max = self.__pyramid.tms.get_level(self.__id).bbox_to_tiles(
            bbox
        )
        self.__tile_limits = {
            &#34;min_row&#34;: row_min,
            &#34;max_col&#34;: col_max,
            &#34;max_row&#34;: row_max,
            &#34;min_col&#34;: col_min,
        }</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="rok4.pyramid.Level.from_descriptor"><code class="name flex">
<span>def <span class="ident">from_descriptor</span></span>(<span>data: Dict[~KT, ~VT], pyramid: <a title="rok4.pyramid.Pyramid" href="#rok4.pyramid.Pyramid">Pyramid</a>) ‑> <a title="rok4.pyramid.Level" href="#rok4.pyramid.Level">Level</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create a pyramid's level from the pyramid's descriptor levels element</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>Dict</code></dt>
<dd>level's information from the pyramid's descriptor</dd>
<dt><strong><code>pyramid</code></strong> :&ensp;<code><a title="rok4.pyramid.Pyramid" href="#rok4.pyramid.Pyramid">Pyramid</a></code></dt>
<dd>pyramid containing the level to create</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>Exception</code></dt>
<dd>different storage or masks presence between the level and the pyramid</dd>
<dt><code>MissingAttributeError</code></dt>
<dd>Attribute is missing in the content</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="rok4.pyramid.Pyramid" href="#rok4.pyramid.Pyramid">Pyramid</a></code></dt>
<dd>a Level instance</dd>
</dl></div>
</dd>
<dt id="rok4.pyramid.Level.from_other"><code class="name flex">
<span>def <span class="ident">from_other</span></span>(<span>other: <a title="rok4.pyramid.Level" href="#rok4.pyramid.Level">Level</a>, pyramid: <a title="rok4.pyramid.Pyramid" href="#rok4.pyramid.Pyramid">Pyramid</a>) ‑> <a title="rok4.pyramid.Level" href="#rok4.pyramid.Level">Level</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create a pyramid's level from another one</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>other</code></strong> :&ensp;<code><a title="rok4.pyramid.Level" href="#rok4.pyramid.Level">Level</a></code></dt>
<dd>level to clone</dd>
<dt><strong><code>pyramid</code></strong> :&ensp;<code><a title="rok4.pyramid.Pyramid" href="#rok4.pyramid.Pyramid">Pyramid</a></code></dt>
<dd>new pyramid containing the new level</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>Exception</code></dt>
<dd>different storage or masks presence between the level and the pyramid</dd>
<dt><code>MissingAttributeError</code></dt>
<dd>Attribute is missing in the content</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="rok4.pyramid.Pyramid" href="#rok4.pyramid.Pyramid">Pyramid</a></code></dt>
<dd>a Level instance</dd>
</dl></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="rok4.pyramid.Level.bbox"><code class="name">prop <span class="ident">bbox</span> : Tuple[float, float, float, float]</code></dt>
<dd>
<div class="desc"><p>Return level extent, based on tile limits</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tuple[float, float, float, float]</code></dt>
<dd>level terrain extent (xmin, ymin, xmax, ymax)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def bbox(self) -&gt; Tuple[float, float, float, float]:
    &#34;&#34;&#34;Return level extent, based on tile limits

    Returns:
        Tuple[float, float, float, float]: level terrain extent (xmin, ymin, xmax, ymax)
    &#34;&#34;&#34;

    min_bbox = self.__pyramid.tms.get_level(self.__id).tile_to_bbox(
        self.__tile_limits[&#34;min_col&#34;], self.__tile_limits[&#34;max_row&#34;]
    )
    max_bbox = self.__pyramid.tms.get_level(self.__id).tile_to_bbox(
        self.__tile_limits[&#34;max_col&#34;], self.__tile_limits[&#34;min_row&#34;]
    )

    return (min_bbox[0], min_bbox[1], max_bbox[2], max_bbox[3])</code></pre>
</details>
</dd>
<dt id="rok4.pyramid.Level.id"><code class="name">prop <span class="ident">id</span> : str</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def id(self) -&gt; str:
    return self.__id</code></pre>
</details>
</dd>
<dt id="rok4.pyramid.Level.resolution"><code class="name">prop <span class="ident">resolution</span> : str</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def resolution(self) -&gt; str:
    return self.__pyramid.tms.get_level(self.__id).resolution</code></pre>
</details>
</dd>
<dt id="rok4.pyramid.Level.serializable"><code class="name">prop <span class="ident">serializable</span> : Dict[~KT, ~VT]</code></dt>
<dd>
<div class="desc"><p>Get the dict version of the pyramid object, pyramid's descriptor compliant</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict</code></dt>
<dd>pyramid's descriptor structured object description</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def serializable(self) -&gt; Dict:
    &#34;&#34;&#34;Get the dict version of the pyramid object, pyramid&#39;s descriptor compliant

    Returns:
        Dict: pyramid&#39;s descriptor structured object description
    &#34;&#34;&#34;
    serialization = {
        &#34;id&#34;: self.__id,
        &#34;tiles_per_width&#34;: self.__slab_size[0],
        &#34;tiles_per_height&#34;: self.__slab_size[1],
        &#34;tile_limits&#34;: self.__tile_limits,
    }

    if self.__pyramid.type == PyramidType.VECTOR:
        serialization[&#34;tables&#34;] = self.__tables

    if self.__pyramid.storage_type == StorageType.FILE:
        serialization[&#34;storage&#34;] = {
            &#34;type&#34;: &#34;FILE&#34;,
            &#34;image_directory&#34;: f&#34;{self.__pyramid.name}/DATA/{self.__id}&#34;,
            &#34;path_depth&#34;: self.__pyramid.storage_depth,
        }
        if self.__pyramid.own_masks:
            serialization[&#34;storage&#34;][
                &#34;mask_directory&#34;
            ] = f&#34;{self.__pyramid.name}/MASK/{self.__id}&#34;

    elif self.__pyramid.storage_type == StorageType.CEPH:
        serialization[&#34;storage&#34;] = {
            &#34;type&#34;: &#34;CEPH&#34;,
            &#34;image_prefix&#34;: f&#34;{self.__pyramid.name}/DATA_{self.__id}&#34;,
            &#34;pool_name&#34;: self.__pyramid.storage_root,
        }
        if self.__pyramid.own_masks:
            serialization[&#34;storage&#34;][&#34;mask_prefix&#34;] = f&#34;{self.__pyramid.name}/MASK_{self.__id}&#34;

    elif self.__pyramid.storage_type == StorageType.S3:
        serialization[&#34;storage&#34;] = {
            &#34;type&#34;: &#34;S3&#34;,
            &#34;image_prefix&#34;: f&#34;{self.__pyramid.name}/DATA_{self.__id}&#34;,
            &#34;bucket_name&#34;: self.__pyramid.storage_root,
        }
        if self.__pyramid.own_masks:
            serialization[&#34;storage&#34;][&#34;mask_prefix&#34;] = f&#34;{self.__pyramid.name}/MASK_{self.__id}&#34;

    return serialization</code></pre>
</details>
</dd>
<dt id="rok4.pyramid.Level.slab_height"><code class="name">prop <span class="ident">slab_height</span> : int</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def slab_height(self) -&gt; int:
    return self.__slab_size[1]</code></pre>
</details>
</dd>
<dt id="rok4.pyramid.Level.slab_width"><code class="name">prop <span class="ident">slab_width</span> : int</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def slab_width(self) -&gt; int:
    return self.__slab_size[0]</code></pre>
</details>
</dd>
<dt id="rok4.pyramid.Level.tile_limits"><code class="name">prop <span class="ident">tile_limits</span> : Dict[str, int]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def tile_limits(self) -&gt; Dict[str, int]:
    return self.__tile_limits</code></pre>
</details>
</dd>
<dt id="rok4.pyramid.Level.tile_matrix"><code class="name">prop <span class="ident">tile_matrix</span> : <a title="rok4.tile_matrix_set.TileMatrix" href="tile_matrix_set.html#rok4.tile_matrix_set.TileMatrix">TileMatrix</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def tile_matrix(self) -&gt; TileMatrix:
    return self.__pyramid.tms.get_level(self.__id)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="rok4.pyramid.Level.is_in_limits"><code class="name flex">
<span>def <span class="ident">is_in_limits</span></span>(<span>self, column: int, row: int) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Is the tile indices in limits ?</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>column</code></strong> :&ensp;<code>int</code></dt>
<dd>tile's column</dd>
<dt><strong><code>row</code></strong> :&ensp;<code>int</code></dt>
<dd>tile's row</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if tiles' limits contain the provided tile's indices</dd>
</dl></div>
</dd>
<dt id="rok4.pyramid.Level.set_limits_from_bbox"><code class="name flex">
<span>def <span class="ident">set_limits_from_bbox</span></span>(<span>self, bbox: Tuple[float, float, float, float]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Set tile limits, based on provided bounding box</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>bbox</code></strong> :&ensp;<code>Tuple[float, float, float, float]</code></dt>
<dd>terrain extent (xmin, ymin, xmax, ymax), in TMS coordinates system</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="rok4.pyramid.Pyramid"><code class="flex name class">
<span>class <span class="ident">Pyramid</span></span>
</code></dt>
<dd>
<div class="desc"><p>A data pyramid, raster or vector</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>__name</code></strong> :&ensp;<code>str</code></dt>
<dd>pyramid's name</dd>
<dt><strong><code>__descriptor</code></strong> :&ensp;<code>str</code></dt>
<dd>pyramid's descriptor path</dd>
<dt><strong><code>__list</code></strong> :&ensp;<code>str</code></dt>
<dd>pyramid's list path</dd>
<dt><strong><code>__tms</code></strong> :&ensp;<code><a title="rok4.tile_matrix_set.TileMatrixSet" href="tile_matrix_set.html#rok4.tile_matrix_set.TileMatrixSet">TileMatrixSet</a></code></dt>
<dd>Used grid</dd>
<dt><strong><code>__levels</code></strong> :&ensp;<code>Dict[str, <a title="rok4.pyramid.Level" href="#rok4.pyramid.Level">Level</a>]</code></dt>
<dd>Pyramid's levels</dd>
<dt><strong><code>__format</code></strong> :&ensp;<code>str</code></dt>
<dd>Data format</dd>
<dt><strong><code>__storage</code></strong> :&ensp;<code>Dict[str, Union[<a title="rok4.enums.StorageType" href="enums.html#rok4.enums.StorageType">StorageType</a>,str,int]]</code></dt>
<dd>Pyramid's storage informations (type, root and depth if FILE storage)</dd>
<dt><strong><code>__raster_specifications</code></strong> :&ensp;<code>Dict</code></dt>
<dd>If raster pyramid, raster specifications</dd>
<dt><strong><code>__content</code></strong> :&ensp;<code>Dict</code></dt>
<dd>
<p>Loading status (loaded), slab count (count) and list content (cache).</p>
<p>Example (S3 storage):</p>
<pre><code>{
    'cache': {
        (&lt;SlabType.DATA: 'DATA'&gt;, '18', 5424, 7526): {
            'link': False,
            'md5': None,
            'root': 'pyramids@localhost:9000/LIMADM',
            'slab': 'DATA_18_5424_7526'
        }
    },
    'count': 1,
    'loaded': True
}
</code></pre>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Pyramid:
    &#34;&#34;&#34;A data pyramid, raster or vector

    Attributes:
        __name (str): pyramid&#39;s name
        __descriptor (str): pyramid&#39;s descriptor path
        __list (str): pyramid&#39;s list path
        __tms (rok4.tile_matrix_set.TileMatrixSet): Used grid
        __levels (Dict[str, Level]): Pyramid&#39;s levels
        __format (str): Data format
        __storage (Dict[str, Union[rok4.enums.StorageType,str,int]]): Pyramid&#39;s storage informations (type, root and depth if FILE storage)
        __raster_specifications (Dict): If raster pyramid, raster specifications
        __content (Dict): Loading status (loaded), slab count (count) and list content (cache).

            Example (S3 storage):

                {
                    &#39;cache&#39;: {
                        (&lt;SlabType.DATA: &#39;DATA&#39;&gt;, &#39;18&#39;, 5424, 7526): {
                            &#39;link&#39;: False,
                            &#39;md5&#39;: None,
                            &#39;root&#39;: &#39;pyramids@localhost:9000/LIMADM&#39;,
                            &#39;slab&#39;: &#39;DATA_18_5424_7526&#39;
                        }
                    },
                    &#39;count&#39;: 1,
                    &#39;loaded&#39;: True
                }
    &#34;&#34;&#34;

    @classmethod
    def from_descriptor(cls, descriptor: str) -&gt; &#34;Pyramid&#34;:
        &#34;&#34;&#34;Create a pyramid from its descriptor

        Args:
            descriptor (str): pyramid&#39;s descriptor path

        Raises:
            FormatError: Provided path or the descriptor is not a well formed JSON
            Exception: Level issue : no one in the pyramid or the used TMS, or level ID not defined in the TMS
            MissingAttributeError: Attribute is missing in the content
            StorageError: Storage read issue (pyramid descriptor or TMS)
            MissingEnvironmentError: Missing object storage informations or TMS root directory

        Examples:

            S3 stored descriptor

                from rok4.pyramid import Pyramid

                try:
                    pyramid = Pyramid.from_descriptor(&#34;s3://bucket_name/path/to/descriptor.json&#34;)
                except Exception as e:
                    print(&#34;Cannot load the pyramid from its descriptor&#34;)

        Returns:
            Pyramid: a Pyramid instance
        &#34;&#34;&#34;
        try:
            data = json.loads(get_data_str(descriptor))

        except JSONDecodeError as e:
            raise FormatError(&#34;JSON&#34;, descriptor, e)

        pyramid = cls()

        pyramid.__storage[&#34;type&#34;], path, pyramid.__storage[&#34;root&#34;], base_name = get_infos_from_path(
            descriptor
        )
        pyramid.__name = base_name[:-5]  # on supprime l&#39;extension.json
        pyramid.__descriptor = descriptor
        pyramid.__list = get_path_from_infos(
            pyramid.__storage[&#34;type&#34;], pyramid.__storage[&#34;root&#34;], f&#34;{pyramid.__name}.list&#34;
        )

        try:
            # Attributs communs
            pyramid.__tms = TileMatrixSet(data[&#34;tile_matrix_set&#34;])
            pyramid.__format = data[&#34;format&#34;]

            # Attributs d&#39;une pyramide raster
            if pyramid.type == PyramidType.RASTER:
                pyramid.__raster_specifications = data[&#34;raster_specifications&#34;]

                if &#34;mask_format&#34; in data:
                    pyramid.__masks = True
                else:
                    pyramid.__masks = False

            # Niveaux
            for level in data[&#34;levels&#34;]:
                lev = Level.from_descriptor(level, pyramid)
                pyramid.__levels[lev.id] = lev

                if pyramid.__tms.get_level(lev.id) is None:
                    raise Exception(
                        f&#34;Pyramid {descriptor} owns a level with the ID &#39;{lev.id}&#39;, not defined in the TMS &#39;{pyramid.tms.name}&#39;&#34;
                    )

        except KeyError as e:
            raise MissingAttributeError(descriptor, e)

        if len(pyramid.__levels.keys()) == 0:
            raise Exception(f&#34;Pyramid &#39;{descriptor}&#39; has no level&#34;)

        return pyramid

    @classmethod
    def from_other(cls, other: &#34;Pyramid&#34;, name: str, storage: Dict, **kwargs) -&gt; &#34;Pyramid&#34;:
        &#34;&#34;&#34;Create a pyramid from another one

        Args:
            other (Pyramid): pyramid to clone
            name (str): new pyramid&#39;s name
            storage (Dict[str, Union[str, int]]): new pyramid&#39;s storage informations
            **mask (bool) : Presence or not of mask (only for RASTER)

        Raises:
            FormatError: Provided path or the TMS is not a well formed JSON
            Exception: Level issue : no one in the pyramid or the used TMS, or level ID not defined in the TMS
            MissingAttributeError: Attribute is missing in the content

        Returns:
            Pyramid: a Pyramid instance
        &#34;&#34;&#34;
        try:
            # On convertit le type de stockage selon l&#39;énumération
            if type(storage[&#34;type&#34;]) is str:
                storage[&#34;type&#34;] = StorageType[storage[&#34;type&#34;]]

            if storage[&#34;type&#34;] == StorageType.FILE and name.find(&#34;/&#34;) != -1:
                raise Exception(f&#34;A FILE stored pyramid&#39;s name cannot contain &#39;/&#39; : &#39;{name}&#39;&#34;)

            if storage[&#34;type&#34;] == StorageType.FILE and &#34;depth&#34; not in storage:
                storage[&#34;depth&#34;] = 2

            pyramid = cls()

            # Attributs communs
            pyramid.__name = name
            pyramid.__storage = storage
            pyramid.__masks = other.__masks

            pyramid.__descriptor = get_path_from_infos(
                pyramid.__storage[&#34;type&#34;], pyramid.__storage[&#34;root&#34;], f&#34;{pyramid.__name}.json&#34;
            )
            pyramid.__list = get_path_from_infos(
                pyramid.__storage[&#34;type&#34;], pyramid.__storage[&#34;root&#34;], f&#34;{pyramid.__name}.list&#34;
            )
            pyramid.__tms = other.__tms
            pyramid.__format = other.__format

            # Attributs d&#39;une pyramide raster
            if pyramid.type == PyramidType.RASTER:
                if &#34;mask&#34; in kwargs:
                    pyramid.__masks = kwargs[&#34;mask&#34;]
                elif other.own_masks:
                    pyramid.__masks = True
                else:
                    pyramid.__masks = False
                pyramid.__raster_specifications = other.__raster_specifications

            # Niveaux
            for level in other.__levels.values():
                lev = Level.from_other(level, pyramid)
                pyramid.__levels[lev.id] = lev

        except KeyError as e:
            raise MissingAttributeError(pyramid.descriptor, e)

        return pyramid

    def __init__(self) -&gt; None:
        self.__storage = {}
        self.__levels = {}
        self.__masks = None

        self.__content = {&#34;loaded&#34;: False, &#34;count&#34;: 0, &#34;cache&#34;: {}}

    def __str__(self) -&gt; str:
        return f&#34;{self.type.name} pyramid &#39;{self.__name}&#39; ({self.__storage[&#39;type&#39;].name} storage)&#34;

    @property
    def serializable(self) -&gt; Dict:
        &#34;&#34;&#34;Get the dict version of the pyramid object, descriptor compliant

        Returns:
            Dict: descriptor structured object description
        &#34;&#34;&#34;

        serialization = {&#34;tile_matrix_set&#34;: self.__tms.name, &#34;format&#34;: self.__format}

        serialization[&#34;levels&#34;] = []
        sorted_levels = sorted(
            self.__levels.values(), key=lambda level: level.resolution, reverse=True
        )

        for level in sorted_levels:
            serialization[&#34;levels&#34;].append(level.serializable)

        if self.type == PyramidType.RASTER:
            serialization[&#34;raster_specifications&#34;] = self.__raster_specifications

        if self.__masks:
            serialization[&#34;mask_format&#34;] = &#34;TIFF_ZIP_UINT8&#34;

        return serialization

    @property
    def list(self) -&gt; str:
        return self.__list

    @property
    def descriptor(self) -&gt; str:
        return self.__descriptor

    @property
    def name(self) -&gt; str:
        return self.__name

    @property
    def tms(self) -&gt; TileMatrixSet:
        return self.__tms

    @property
    def raster_specifications(self) -&gt; Dict:
        &#34;&#34;&#34;Get raster specifications for a RASTER pyramid

        Example:

            RGB pyramid with red nodata

                {
                    &#34;channels&#34;: 3,
                    &#34;nodata&#34;: &#34;255,0,0&#34;,
                    &#34;photometric&#34;: &#34;rgb&#34;,
                    &#34;interpolation&#34;: &#34;bicubic&#34;
                }

        Returns:
            Dict: Raster specifications, None if VECTOR pyramid
        &#34;&#34;&#34;
        return self.__raster_specifications

    @property
    def storage_type(self) -&gt; StorageType:
        &#34;&#34;&#34;Get the storage type

        Returns:
            StorageType: FILE, S3 or CEPH
        &#34;&#34;&#34;
        return self.__storage[&#34;type&#34;]

    @property
    def storage_root(self) -&gt; str:
        &#34;&#34;&#34;Get the pyramid&#39;s storage root.

        If storage is S3, the used cluster is removed.

        Returns:
            str: Pyramid&#39;s storage root
        &#34;&#34;&#34;

        return self.__storage[&#34;root&#34;].split(&#34;@&#34;, 1)[
            0
        ]  # Suppression de l&#39;éventuel hôte de spécification du cluster S3

    @property
    def storage_depth(self) -&gt; int:
        return self.__storage.get(&#34;depth&#34;, None)

    @property
    def storage_s3_cluster(self) -&gt; str:
        &#34;&#34;&#34;Get the pyramid&#39;s storage S3 cluster (host name)

        Returns:
            str: the host if known, None if the default one have to be used or if storage is not S3
        &#34;&#34;&#34;
        if self.__storage[&#34;type&#34;] == StorageType.S3:
            try:
                return self.__storage[&#34;root&#34;].split(&#34;@&#34;)[1]
            except IndexError:
                return None
        else:
            return None

    @storage_depth.setter
    def storage_depth(self, d: int) -&gt; None:
        &#34;&#34;&#34;Set the tree depth for a FILE storage

        Args:
            d (int): file storage depth

        Raises:
            Exception: the depth is not equal to the already known depth
        &#34;&#34;&#34;
        if &#34;depth&#34; in self.__storage and self.__storage[&#34;depth&#34;] != d:
            raise Exception(f&#34;Pyramid {self.__descriptor} owns levels with different path depths&#34;)
        self.__storage[&#34;depth&#34;] = d

    @property
    def own_masks(self) -&gt; bool:
        return self.__masks

    @property
    def format(self) -&gt; str:
        return self.__format

    @property
    def channels(self) -&gt; str:
        return self.raster_specifications[&#34;channels&#34;]

    @property
    def tile_extension(self) -&gt; str:
        if self.__format in [
            &#34;TIFF_RAW_UINT8&#34;,
            &#34;TIFF_LZW_UINT8&#34;,
            &#34;TIFF_ZIP_UINT8&#34;,
            &#34;TIFF_PKB_UINT8&#34;,
            &#34;TIFF_RAW_FLOAT32&#34;,
            &#34;TIFF_LZW_FLOAT32&#34;,
            &#34;TIFF_ZIP_FLOAT32&#34;,
            &#34;TIFF_PKB_FLOAT32&#34;,
        ]:
            return &#34;tif&#34;
        elif self.__format in [&#34;TIFF_JPG_UINT8&#34;, &#34;TIFF_JPG90_UINT8&#34;]:
            return &#34;jpg&#34;
        elif self.__format == &#34;TIFF_PNG_UINT8&#34;:
            return &#34;png&#34;
        elif self.__format == &#34;TIFF_PBF_MVT&#34;:
            return &#34;pbf&#34;
        else:
            raise Exception(
                f&#34;Unknown pyramid&#39;s format ({self.__format}), cannot return the tile extension&#34;
            )

    @property
    def bottom_level(self) -&gt; &#34;Level&#34;:
        &#34;&#34;&#34;Get the best resolution level in the pyramid

        Returns:
            Level: the bottom level
        &#34;&#34;&#34;
        return sorted(self.__levels.values(), key=lambda level: level.resolution)[0]

    @property
    def top_level(self) -&gt; &#34;Level&#34;:
        &#34;&#34;&#34;Get the low resolution level in the pyramid

        Returns:
            Level: the top level
        &#34;&#34;&#34;
        return sorted(self.__levels.values(), key=lambda level: level.resolution)[-1]

    @property
    def type(self) -&gt; PyramidType:
        &#34;&#34;&#34;Get the pyramid&#39;s type (RASTER or VECTOR) from its format

        Returns:
            PyramidType: RASTER or VECTOR
        &#34;&#34;&#34;
        if self.__format == &#34;TIFF_PBF_MVT&#34;:
            return PyramidType.VECTOR
        else:
            return PyramidType.RASTER

    def load_list(self) -&gt; int:
        &#34;&#34;&#34;Load list content and cache it

        If list is already loaded, nothing done
        &#34;&#34;&#34;
        if self.__content[&#34;loaded&#34;]:
            return self.__content[&#34;count&#34;]

        for slab, infos in self.list_generator():
            self.__content[&#34;cache&#34;][slab] = infos
            self.__content[&#34;count&#34;] += 1

        self.__content[&#34;loaded&#34;] = True

        return self.__content[&#34;count&#34;]

    def list_generator(
        self, level_id: str = None
    ) -&gt; Iterator[Tuple[Tuple[SlabType, str, int, int], Dict]]:
        &#34;&#34;&#34;Get list content

        List is copied as temporary file, roots are read and informations about each slab is returned. If list is already loaded, we yield the cached content
        Args :
            level_id (str) : id of the level for load only one level

        Examples:

            S3 stored descriptor

                from rok4.pyramid import Pyramid

                try:
                    pyramid = Pyramid.from_descriptor(&#34;s3://bucket_name/path/to/descriptor.json&#34;)

                    for (slab_type, level, column, row), infos in pyramid.list_generator():
                        print(infos)

                except Exception as e:
                    print(&#34;Cannot load the pyramid from its descriptor and read the list&#34;)

        Yields:
            Iterator[Tuple[Tuple[SlabType,str,int,int], Dict]]: Slab indices and storage informations

            Value example:

                (
                    (&lt;SlabType.DATA: &#39;DATA&#39;&gt;, &#39;18&#39;, 5424, 7526),
                    {
                        &#39;link&#39;: False,
                        &#39;md5&#39;: None,
                        &#39;root&#39;: &#39;pyramids@localhost:9000/LIMADM&#39;,
                        &#39;slab&#39;: &#39;DATA_18_5424_7526&#39;
                    }
                )

        Raises:
            StorageError: Unhandled pyramid storage to copy list
            MissingEnvironmentError: Missing object storage informations
        &#34;&#34;&#34;
        if self.__content[&#34;loaded&#34;]:
            for slab, infos in self.__content[&#34;cache&#34;].items():
                if level_id is not None:
                    if slab[1] == level_id:
                        yield slab, infos
                else:
                    yield slab, infos
        else:
            # Copie de la liste dans un fichier temporaire (cette liste peut être un objet)
            list_obj = tempfile.NamedTemporaryFile(mode=&#34;r&#34;, delete=False)
            list_file = list_obj.name
            copy(self.__list, f&#34;file://{list_file}&#34;)
            list_obj.close()

            roots = {}
            s3_cluster = self.storage_s3_cluster

            with open(list_file) as listin:
                # Lecture des racines
                for line in listin:
                    line = line.rstrip()

                    if line == &#34;#&#34;:
                        break

                    root_id, root_path = line.split(&#34;=&#34;, 1)

                    if s3_cluster is None:
                        roots[root_id] = root_path
                    else:
                        # On a un nom de cluster S3, on l&#39;ajoute au nom du bucket dans les racines
                        root_bucket, root_path = root_path.split(&#34;/&#34;, 1)
                        roots[root_id] = f&#34;{root_bucket}@{s3_cluster}/{root_path}&#34;

                # Lecture des dalles
                for line in listin:
                    line = line.rstrip()

                    parts = line.split(&#34; &#34;, 1)
                    slab_path = parts[0]
                    slab_md5 = None
                    if len(parts) == 2:
                        slab_md5 = parts[1]

                    root_id, slab_path = slab_path.split(&#34;/&#34;, 1)

                    slab_type, level, column, row = self.get_infos_from_slab_path(slab_path)
                    infos = {
                        &#34;root&#34;: roots[root_id],
                        &#34;link&#34;: root_id != &#34;0&#34;,
                        &#34;slab&#34;: slab_path,
                        &#34;md5&#34;: slab_md5,
                    }

                    if level_id is not None:
                        if level == level_id:
                            yield ((slab_type, level, column, row), infos)
                    else:
                        yield ((slab_type, level, column, row), infos)

            remove(f&#34;file://{list_file}&#34;)

    def get_level(self, level_id: str) -&gt; &#34;Level&#34;:
        &#34;&#34;&#34;Get one level according to its identifier

        Args:
            level_id: Level identifier

        Returns:
            The corresponding pyramid&#39;s level, None if not present
        &#34;&#34;&#34;

        return self.__levels.get(level_id, None)

    def get_levels(self, bottom_id: str = None, top_id: str = None) -&gt; List[Level]:
        &#34;&#34;&#34;Get sorted levels in the provided range from bottom to top

        Args:
            bottom_id (str, optionnal): specific bottom level id. Defaults to None.
            top_id (str, optionnal): specific top level id. Defaults to None.

        Raises:
            Exception: Provided levels are not consistent (bottom &gt; top or not in the pyramid)

        Examples:

            All levels

                from rok4.pyramid import Pyramid

                try:
                    pyramid = Pyramid.from_descriptor(&#34;s3://bucket_name/path/to/descriptor.json&#34;)
                    levels = pyramid.get_levels()

                except Exception as e:
                    print(&#34;Cannot load the pyramid from its descriptor and get levels&#34;)

            From pyramid&#39;s bottom to provided top (level 5)

                from rok4.pyramid import Pyramid

                try:
                    pyramid = Pyramid.from_descriptor(&#34;s3://bucket_name/path/to/descriptor.json&#34;)
                    levels = pyramid.get_levels(None, &#34;5&#34;)

                except Exception as e:
                    print(&#34;Cannot load the pyramid from its descriptor and get levels&#34;)

        Returns:
            List[Level]: asked sorted levels
        &#34;&#34;&#34;

        sorted_levels = sorted(self.__levels.values(), key=lambda level: level.resolution)

        levels = []

        begin = False
        if bottom_id is None:
            # Pas de niveau du bas fourni, on commence tout en bas
            begin = True
        else:
            if self.get_level(bottom_id) is None:
                raise Exception(
                    f&#34;Pyramid {self.name} does not contain the provided bottom level {bottom_id}&#34;
                )

        if top_id is not None and self.get_level(top_id) is None:
            raise Exception(f&#34;Pyramid {self.name} does not contain the provided top level {top_id}&#34;)

        end = False

        for level in sorted_levels:
            if not begin and level.id == bottom_id:
                begin = True

            if begin:
                levels.append(level)
                if top_id is not None and level.id == top_id:
                    end = True
                    break
                else:
                    continue

        if top_id is None:
            # Pas de niveau du haut fourni, on a été jusqu&#39;en haut et c&#39;est normal
            end = True

        if not begin or not end:
            raise Exception(
                f&#34;Provided levels ids are not consistent to extract levels from the pyramid {self.name}&#34;
            )

        return levels

    def write_descriptor(self) -&gt; None:
        &#34;&#34;&#34;Write the pyramid&#39;s descriptor to the final location (in the pyramid&#39;s storage root)&#34;&#34;&#34;

        content = json.dumps(self.serializable)
        put_data_str(content, self.__descriptor)

    def get_infos_from_slab_path(self, path: str) -&gt; Tuple[SlabType, str, int, int]:
        &#34;&#34;&#34;Get the slab&#39;s indices from its storage path

        Args:
            path (str): Slab&#39;s storage path

        Examples:

            FILE stored pyramid

                from rok4.pyramid import Pyramid

                try:
                    pyramid = Pyramid.from_descriptor(&#34;/path/to/descriptor.json&#34;)
                    slab_type, level, column, row = self.get_infos_from_slab_path(&#34;DATA/12/00/4A/F7.tif&#34;)
                    # (SlabType.DATA, &#34;12&#34;, 159, 367)
                except Exception as e:
                    print(&#34;Cannot load the pyramid from its descriptor and convert a slab path&#34;)

            S3 stored pyramid

                from rok4.pyramid import Pyramid

                try:
                    pyramid = Pyramid.from_descriptor(&#34;s3://bucket_name/path/to/pyramid.json&#34;)
                    slab_type, level, column, row = self.get_infos_from_slab_path(&#34;s3://bucket_name/path/to/pyramid/MASK_15_9164_5846&#34;)
                    # (SlabType.MASK, &#34;15&#34;, 9164, 5846)
                except Exception as e:
                    print(&#34;Cannot load the pyramid from its descriptor and convert a slab path&#34;)

        Returns:
            Tuple[SlabType, str, int, int]: Slab&#39;s type (DATA or MASK), level identifier, slab&#39;s column and slab&#39;s row
        &#34;&#34;&#34;
        if self.__storage[&#34;type&#34;] == StorageType.FILE:
            parts = path.split(&#34;/&#34;)

            # Le partie du chemin qui contient la colonne et ligne de la dalle est à la fin, en fonction de la profondeur choisie
            # depth = 2 -&gt; on doit utiliser les 3 dernières parties pour la conversion
            column, row = b36_path_decode(&#34;/&#34;.join(parts[-(self.__storage[&#34;depth&#34;] + 1) :]))
            level = parts[-(self.__storage[&#34;depth&#34;] + 2)]
            raw_slab_type = parts[-(self.__storage[&#34;depth&#34;] + 3)]

            # Pour être retro compatible avec l&#39;ancien nommage
            if raw_slab_type == &#34;IMAGE&#34;:
                raw_slab_type = &#34;DATA&#34;

            slab_type = SlabType[raw_slab_type]

            return slab_type, level, column, row
        else:
            parts = re.split(r&#34;[/_]&#34;, path)
            column = parts[-2]
            row = parts[-1]
            level = parts[-3]
            raw_slab_type = parts[-4]

            # Pour être retro compatible avec l&#39;ancien nommage
            if raw_slab_type == &#34;IMG&#34;:
                raw_slab_type = &#34;DATA&#34;
            elif raw_slab_type == &#34;MSK&#34;:
                raw_slab_type = &#34;MASK&#34;

            slab_type = SlabType[raw_slab_type]

            return slab_type, level, int(column), int(row)

    def get_slab_path_from_infos(
        self, slab_type: SlabType, level: str, column: int, row: int, full: bool = True
    ) -&gt; str:
        &#34;&#34;&#34;Get slab&#39;s storage path from the indices

        Args:
            slab_type (SlabType): DATA or MASK
            level (str): Level identifier
            column (int): Slab&#39;s column
            row (int): Slab&#39;s row
            full (bool, optional): Full path or just relative path from pyramid storage root. Defaults to True.

        Returns:
            str: Absolute or relative slab&#39;s storage path
        &#34;&#34;&#34;
        if self.__storage[&#34;type&#34;] == StorageType.FILE:
            slab_path = os.path.join(
                slab_type.value, level, b36_path_encode(column, row, self.__storage[&#34;depth&#34;])
            )
        else:
            slab_path = f&#34;{slab_type.value}_{level}_{column}_{row}&#34;

        if full:
            return get_path_from_infos(
                self.__storage[&#34;type&#34;], self.__storage[&#34;root&#34;], self.__name, slab_path
            )
        else:
            return slab_path

    def get_tile_data_binary(self, level: str, column: int, row: int) -&gt; str:
        &#34;&#34;&#34;Get a pyramid&#39;s tile as binary string

        To get a tile, 3 steps :
            * calculate slab path from tile index
            * read slab index to get offsets and sizes of slab&#39;s tiles
            * read the tile into the slab

        Args:
            level (str): Tile&#39;s level
            column (int): Tile&#39;s column
            row (int): Tile&#39;s row

        Limitations:
            Pyramids with one-tile slab are not handled

        Examples:

            FILE stored raster pyramid, to extract a tile containing a point and save it as independent image

                from rok4.pyramid import Pyramid

                try:
                    pyramid = Pyramid.from_descriptor(&#34;/data/pyramids/SCAN1000.json&#34;)
                    level, col, row, pcol, prow = pyramid.get_tile_indices(992904.46, 6733643.15, &#34;9&#34;, srs = &#34;IGNF:LAMB93&#34;)
                    data = pyramid.get_tile_data_binary(level, col, row)

                    if data is None:
                        print(&#34;No data&#34;)
                    else:
                        tile_name = f&#34;tile_{level}_{col}_{row}.{pyramid.tile_extension}&#34;
                        with open(tile_name, &#34;wb&#34;) as image:
                            image.write(data)
                        print (f&#34;Tile written in {tile_name}&#34;)

                except Exception as e:
                    print(&#34;Cannot save a pyramid&#39;s tile : {e}&#34;)

        Raises:
            Exception: Level not found in the pyramid
            NotImplementedError: Pyramid owns one-tile slabs
            MissingEnvironmentError: Missing object storage informations
            StorageError: Storage read issue

        Returns:
            str: data, as binary string, None if no data
        &#34;&#34;&#34;

        level_object = self.get_level(level)

        if level_object is None:
            raise Exception(f&#34;No level {level} in the pyramid&#34;)

        if level_object.slab_width == 1 and level_object.slab_height == 1:
            raise NotImplementedError(&#34;One-tile slab pyramid is not handled&#34;)

        if not level_object.is_in_limits(column, row):
            return None

        # Indices de la dalle
        slab_column = column // level_object.slab_width
        slab_row = row // level_object.slab_height

        # Indices de la tuile dans la dalle
        relative_tile_column = column % level_object.slab_width
        relative_tile_row = row % level_object.slab_height

        # Numéro de la tuile dans le header
        tile_index = relative_tile_row * level_object.slab_width + relative_tile_column

        # Calcul du chemin de la dalle contenant la tuile voulue
        slab_path = self.get_slab_path_from_infos(SlabType.DATA, level, slab_column, slab_row)

        # Récupération des offset et tailles des tuiles dans la dalle
        # Une dalle ROK4 a une en-tête fixe de 2048 octets,
        # puis sont stockés les offsets (chacun sur 4 octets)
        # puis les tailles (chacune sur 4 octets)
        try:
            binary_index = get_data_binary(
                slab_path,
                (
                    ROK4_IMAGE_HEADER_SIZE,
                    2 * 4 * level_object.slab_width * level_object.slab_height,
                ),
            )
        except FileNotFoundError:
            # L&#39;absence de la dalle est gérée comme simplement une absence de données
            return None

        offsets = numpy.frombuffer(
            binary_index,
            dtype=numpy.dtype(&#34;uint32&#34;),
            count=level_object.slab_width * level_object.slab_height,
        )
        sizes = numpy.frombuffer(
            binary_index,
            dtype=numpy.dtype(&#34;uint32&#34;),
            offset=4 * level_object.slab_width * level_object.slab_height,
            count=level_object.slab_width * level_object.slab_height,
        )

        if sizes[tile_index] == 0:
            return None

        return get_data_binary(slab_path, (offsets[tile_index], sizes[tile_index]))

    def get_tile_data_raster(self, level: str, column: int, row: int) -&gt; numpy.ndarray:
        &#34;&#34;&#34;Get a raster pyramid&#39;s tile as 3-dimension numpy ndarray

        First dimension is the row, second one is column, third one is band.

        Args:
            level (str): Tile&#39;s level
            column (int): Tile&#39;s column
            row (int): Tile&#39;s row

        Limitations:
            Packbits (pyramid formats TIFF_PKB_FLOAT32 and TIFF_PKB_UINT8) and LZW (pyramid formats TIFF_LZW_FLOAT32 and TIFF_LZW_UINT8) compressions are not handled.

        Raises:
            Exception: Cannot get raster data for a vector pyramid
            Exception: Level not found in the pyramid
            NotImplementedError: Pyramid owns one-tile slabs
            NotImplementedError: Raster pyramid format not handled
            MissingEnvironmentError: Missing object storage informations
            StorageError: Storage read issue
            FormatError: Cannot decode tile

        Examples:

            FILE stored DTM (raster) pyramid, to get the altitude value at a point in the best level

                from rok4.pyramid import Pyramid

                try:
                    pyramid = Pyramid.from_descriptor(&#34;/data/pyramids/RGEALTI.json&#34;)
                    level, col, row, pcol, prow = pyramid.get_tile_indices(44, 5, srs = &#34;EPSG:4326&#34;)
                    data = pyramid.get_tile_data_raster(level, col, row)

                    if data is None:
                        print(&#34;No data&#34;)
                    else:
                        print(data[prow][pcol])

                except Exception as e:
                    print(&#34;Cannot get a pyramid&#39;s pixel value : {e}&#34;)

        Returns:
            str: data, as numpy array, None if no data
        &#34;&#34;&#34;

        if self.type == PyramidType.VECTOR:
            raise Exception(&#34;Cannot get tile as raster data : it&#39;s a vector pyramid&#34;)

        binary_tile = self.get_tile_data_binary(level, column, row)

        if binary_tile is None:
            return None

        level_object = self.get_level(level)

        if self.__format == &#34;TIFF_JPG_UINT8&#34; or self.__format == &#34;TIFF_JPG90_UINT8&#34;:
            try:
                img = Image.open(io.BytesIO(binary_tile))
            except Exception as e:
                raise FormatError(&#34;JPEG&#34;, &#34;binary tile&#34;, e)

            data = numpy.asarray(img)
            data.shape = (
                level_object.tile_matrix.tile_size[0],
                level_object.tile_matrix.tile_size[1],
                self.__raster_specifications[&#34;channels&#34;],
            )

        elif self.__format == &#34;TIFF_RAW_UINT8&#34;:
            data = numpy.frombuffer(binary_tile, dtype=numpy.dtype(&#34;uint8&#34;))
            data.shape = (
                level_object.tile_matrix.tile_size[0],
                level_object.tile_matrix.tile_size[1],
                self.__raster_specifications[&#34;channels&#34;],
            )

        elif self.__format == &#34;TIFF_PNG_UINT8&#34;:
            try:
                img = Image.open(io.BytesIO(binary_tile))
            except Exception as e:
                raise FormatError(&#34;PNG&#34;, &#34;binary tile&#34;, e)

            data = numpy.asarray(img)
            data.shape = (
                level_object.tile_matrix.tile_size[0],
                level_object.tile_matrix.tile_size[1],
                self.__raster_specifications[&#34;channels&#34;],
            )

        elif self.__format == &#34;TIFF_ZIP_UINT8&#34;:
            try:
                data = numpy.frombuffer(zlib.decompress(binary_tile), dtype=numpy.dtype(&#34;uint8&#34;))
            except Exception as e:
                raise FormatError(&#34;ZIP&#34;, &#34;binary tile&#34;, e)

            data.shape = (
                level_object.tile_matrix.tile_size[0],
                level_object.tile_matrix.tile_size[1],
                self.__raster_specifications[&#34;channels&#34;],
            )

        elif self.__format == &#34;TIFF_ZIP_FLOAT32&#34;:
            try:
                data = numpy.frombuffer(zlib.decompress(binary_tile), dtype=numpy.dtype(&#34;float32&#34;))
            except Exception as e:
                raise FormatError(&#34;ZIP&#34;, &#34;binary tile&#34;, e)

            data.shape = (
                level_object.tile_matrix.tile_size[0],
                level_object.tile_matrix.tile_size[1],
                self.__raster_specifications[&#34;channels&#34;],
            )

        elif self.__format == &#34;TIFF_RAW_FLOAT32&#34;:
            data = numpy.frombuffer(binary_tile, dtype=numpy.dtype(&#34;float32&#34;))
            data.shape = (
                level_object.tile_matrix.tile_size[0],
                level_object.tile_matrix.tile_size[1],
                self.__raster_specifications[&#34;channels&#34;],
            )

        else:
            raise NotImplementedError(f&#34;Cannot get tile as raster data for format {self.__format}&#34;)

        return data

    def get_tile_data_vector(self, level: str, column: int, row: int) -&gt; Dict:
        &#34;&#34;&#34;Get a vector pyramid&#39;s tile as GeoJSON dictionnary

        Args:
            level (str): Tile&#39;s level
            column (int): Tile&#39;s column
            row (int): Tile&#39;s row

        Raises:
            Exception: Cannot get vector data for a raster pyramid
            Exception: Level not found in the pyramid
            NotImplementedError: Pyramid owns one-tile slabs
            NotImplementedError: Vector pyramid format not handled
            MissingEnvironmentError: Missing object storage informations
            StorageError: Storage read issue
            FormatError: Cannot decode tile

        Examples:

            S3 stored vector pyramid, to print a tile as GeoJSON

                from rok4.pyramid import Pyramid

                import json

                try:
                    pyramid = Pyramid.from_descriptor(&#34;s3://pyramids/vectors/BDTOPO.json&#34;)
                    level, col, row, pcol, prow = pyramid.get_tile_indices(40.325, 3.123, srs = &#34;EPSG:4326&#34;)
                    data = pyramid.get_tile_data_vector(level, col, row)

                    if data is None:
                        print(&#34;No data&#34;)
                    else:
                        print(json.dumps(data))

                except Exception as e:
                    print(&#34;Cannot print a vector pyramid&#39;s tile as GeoJSON : {e}&#34;)

        Returns:
            str: data, as GeoJSON dictionnary. None if no data
        &#34;&#34;&#34;

        if self.type == PyramidType.RASTER:
            raise Exception(&#34;Cannot get tile as vector data : it&#39;s a raster pyramid&#34;)

        binary_tile = self.get_tile_data_binary(level, column, row)

        if binary_tile is None:
            return None

        self.get_level(level)

        if self.__format == &#34;TIFF_PBF_MVT&#34;:
            try:
                data = mapbox_vector_tile.decode(binary_tile)
            except Exception as e:
                raise FormatError(&#34;PBF (MVT)&#34;, &#34;binary tile&#34;, e)
        else:
            raise NotImplementedError(f&#34;Cannot get tile as vector data for format {self.__format}&#34;)

        return data

    def get_tile_indices(
        self, x: float, y: float, level: str = None, **kwargs
    ) -&gt; Tuple[str, int, int, int, int]:
        &#34;&#34;&#34;Get pyramid&#39;s tile and pixel indices from point&#39;s coordinates

        Used coordinates system have to be the pyramid one. If EPSG:4326, x is latitude and y longitude.

        Args:
            x (float): point&#39;s x
            y (float): point&#39;s y
            level (str, optional): Pyramid&#39;s level to take into account, the bottom one if None . Defaults to None.
            **srs (string): spatial reference system of provided coordinates, with authority and code (same as the pyramid&#39;s one if not provided)

        Raises:
            Exception: Cannot find level to calculate indices
            RuntimeError: Provided SRS is invalid for OSR

        Examples:

            FILE stored DTM (raster) pyramid, to get the altitude value at a point in the best level

                from rok4.pyramid import Pyramid

                try:
                    pyramid = Pyramid.from_descriptor(&#34;/data/pyramids/RGEALTI.json&#34;)
                    level, col, row, pcol, prow = pyramid.get_tile_indices(44, 5, srs = &#34;EPSG:4326&#34;)
                    data = pyramid.get_tile_data_raster(level, col, row)

                    if data is None:
                        print(&#34;No data&#34;)
                    else:
                        print(data[prow][pcol])

                except Exception as e:
                    print(&#34;Cannot get a pyramid&#39;s pixel value : {e}&#34;)

        Returns:
            Tuple[str, int, int, int, int]: Level identifier, tile&#39;s column, tile&#39;s row, pixel&#39;s (in the tile) column, pixel&#39;s row
        &#34;&#34;&#34;

        level_object = self.bottom_level
        if level is not None:
            level_object = self.get_level(level)

        if level_object is None:
            raise Exception(&#34;Cannot found the level to calculate indices&#34;)

        if (
            &#34;srs&#34; in kwargs
            and kwargs[&#34;srs&#34;] is not None
            and kwargs[&#34;srs&#34;].upper() != self.__tms.srs.upper()
        ):
            sr = srs_to_spatialreference(kwargs[&#34;srs&#34;])
            x, y = reproject_point((x, y), sr, self.__tms.sr)

        return (level_object.id,) + level_object.tile_matrix.point_to_indices(x, y)

    def delete_level(self, level_id: str) -&gt; None:
        &#34;&#34;&#34;Delete the given level in the description of the pyramid

        Args:
            level_id: Level identifier

        Raises:
            Exception: Cannot find level
        &#34;&#34;&#34;

        try:
            del self.__levels[level_id]
        except Exception:
            raise Exception(f&#34;The level {level_id} don&#39;t exist in the pyramid&#34;)

    def add_level(
        self,
        level_id: str,
        tiles_per_width: int,
        tiles_per_height: int,
        tile_limits: Dict[str, int],
    ) -&gt; None:
        &#34;&#34;&#34;Add a level in the description of the pyramid

        Args:
            level_id: Level identifier
            tiles_per_width : Number of tiles in width by slab
            tiles_per_height : Number of tiles in height by slab
            tile_limits : Minimum and maximum tiles&#39; columns and rows of pyramid&#39;s content
        &#34;&#34;&#34;

        data = {
            &#34;id&#34;: level_id,
            &#34;tile_limits&#34;: tile_limits,
            &#34;tiles_per_width&#34;: tiles_per_width,
            &#34;tiles_per_height&#34;: tiles_per_height,
            &#34;storage&#34;: {&#34;type&#34;: self.storage_type.name},
        }
        if self.own_masks:
            data[&#34;storage&#34;][&#34;mask_prefix&#34;] = True
        if self.storage_type == StorageType.FILE:
            data[&#34;storage&#34;][&#34;path_depth&#34;] = self.storage_depth

        lev = Level.from_descriptor(data, self)

        if self.__tms.get_level(lev.id) is None:
            raise Exception(
                f&#34;Pyramid {self.name} owns a level with the ID &#39;{lev.id}&#39;, not defined in the TMS &#39;{self.tms.name}&#39;&#34;
            )
        else:
            self.__levels[lev.id] = lev

    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;Get the size of the pyramid

        Examples:

                from rok4.pyramid import Pyramid

                try:
                    pyramid = Pyramid.from_descriptor(&#34;s3://bucket_name/path/to/descriptor.json&#34;)
                    size = pyramid.size()

                except Exception as e:
                    print(&#34;Cannot load the pyramid from its descriptor and get his size&#34;)

        Returns:
            int: size of the pyramid
        &#34;&#34;&#34;

        if not hasattr(self, &#34;_Pyramid__size&#34;):
            self.__size = size_path(
                get_path_from_infos(self.__storage[&#34;type&#34;], self.__storage[&#34;root&#34;], self.__name)
            )

        return self.__size</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="rok4.pyramid.Pyramid.from_descriptor"><code class="name flex">
<span>def <span class="ident">from_descriptor</span></span>(<span>descriptor: str) ‑> <a title="rok4.pyramid.Pyramid" href="#rok4.pyramid.Pyramid">Pyramid</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create a pyramid from its descriptor</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>descriptor</code></strong> :&ensp;<code>str</code></dt>
<dd>pyramid's descriptor path</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>FormatError</code></dt>
<dd>Provided path or the descriptor is not a well formed JSON</dd>
<dt><code>Exception</code></dt>
<dd>Level issue : no one in the pyramid or the used TMS, or level ID not defined in the TMS</dd>
<dt><code>MissingAttributeError</code></dt>
<dd>Attribute is missing in the content</dd>
<dt><code>StorageError</code></dt>
<dd>Storage read issue (pyramid descriptor or TMS)</dd>
<dt><code>MissingEnvironmentError</code></dt>
<dd>Missing object storage informations or TMS root directory</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>S3 stored descriptor</p>
<pre><code>from rok4.pyramid import Pyramid

try:
    pyramid = Pyramid.from_descriptor("s3://bucket_name/path/to/descriptor.json")
except Exception as e:
    print("Cannot load the pyramid from its descriptor")
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="rok4.pyramid.Pyramid" href="#rok4.pyramid.Pyramid">Pyramid</a></code></dt>
<dd>a Pyramid instance</dd>
</dl></div>
</dd>
<dt id="rok4.pyramid.Pyramid.from_other"><code class="name flex">
<span>def <span class="ident">from_other</span></span>(<span>other: <a title="rok4.pyramid.Pyramid" href="#rok4.pyramid.Pyramid">Pyramid</a>, name: str, storage: Dict[~KT, ~VT], **kwargs) ‑> <a title="rok4.pyramid.Pyramid" href="#rok4.pyramid.Pyramid">Pyramid</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create a pyramid from another one</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>other</code></strong> :&ensp;<code><a title="rok4.pyramid.Pyramid" href="#rok4.pyramid.Pyramid">Pyramid</a></code></dt>
<dd>pyramid to clone</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>new pyramid's name</dd>
<dt><strong><code>storage</code></strong> :&ensp;<code>Dict[str, Union[str, int]]</code></dt>
<dd>new pyramid's storage informations</dd>
</dl>
<p>**mask (bool) : Presence or not of mask (only for RASTER)</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>FormatError</code></dt>
<dd>Provided path or the TMS is not a well formed JSON</dd>
<dt><code>Exception</code></dt>
<dd>Level issue : no one in the pyramid or the used TMS, or level ID not defined in the TMS</dd>
<dt><code>MissingAttributeError</code></dt>
<dd>Attribute is missing in the content</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="rok4.pyramid.Pyramid" href="#rok4.pyramid.Pyramid">Pyramid</a></code></dt>
<dd>a Pyramid instance</dd>
</dl></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="rok4.pyramid.Pyramid.bottom_level"><code class="name">prop <span class="ident">bottom_level</span> : <a title="rok4.pyramid.Level" href="#rok4.pyramid.Level">Level</a></code></dt>
<dd>
<div class="desc"><p>Get the best resolution level in the pyramid</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="rok4.pyramid.Level" href="#rok4.pyramid.Level">Level</a></code></dt>
<dd>the bottom level</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def bottom_level(self) -&gt; &#34;Level&#34;:
    &#34;&#34;&#34;Get the best resolution level in the pyramid

    Returns:
        Level: the bottom level
    &#34;&#34;&#34;
    return sorted(self.__levels.values(), key=lambda level: level.resolution)[0]</code></pre>
</details>
</dd>
<dt id="rok4.pyramid.Pyramid.channels"><code class="name">prop <span class="ident">channels</span> : str</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def channels(self) -&gt; str:
    return self.raster_specifications[&#34;channels&#34;]</code></pre>
</details>
</dd>
<dt id="rok4.pyramid.Pyramid.descriptor"><code class="name">prop <span class="ident">descriptor</span> : str</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def descriptor(self) -&gt; str:
    return self.__descriptor</code></pre>
</details>
</dd>
<dt id="rok4.pyramid.Pyramid.format"><code class="name">prop <span class="ident">format</span> : str</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def format(self) -&gt; str:
    return self.__format</code></pre>
</details>
</dd>
<dt id="rok4.pyramid.Pyramid.list"><code class="name">prop <span class="ident">list</span> : str</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def list(self) -&gt; str:
    return self.__list</code></pre>
</details>
</dd>
<dt id="rok4.pyramid.Pyramid.name"><code class="name">prop <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self) -&gt; str:
    return self.__name</code></pre>
</details>
</dd>
<dt id="rok4.pyramid.Pyramid.own_masks"><code class="name">prop <span class="ident">own_masks</span> : bool</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def own_masks(self) -&gt; bool:
    return self.__masks</code></pre>
</details>
</dd>
<dt id="rok4.pyramid.Pyramid.raster_specifications"><code class="name">prop <span class="ident">raster_specifications</span> : Dict[~KT, ~VT]</code></dt>
<dd>
<div class="desc"><p>Get raster specifications for a RASTER pyramid</p>
<h2 id="example">Example</h2>
<p>RGB pyramid with red nodata</p>
<pre><code>{
    "channels": 3,
    "nodata": "255,0,0",
    "photometric": "rgb",
    "interpolation": "bicubic"
}
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict</code></dt>
<dd>Raster specifications, None if VECTOR pyramid</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def raster_specifications(self) -&gt; Dict:
    &#34;&#34;&#34;Get raster specifications for a RASTER pyramid

    Example:

        RGB pyramid with red nodata

            {
                &#34;channels&#34;: 3,
                &#34;nodata&#34;: &#34;255,0,0&#34;,
                &#34;photometric&#34;: &#34;rgb&#34;,
                &#34;interpolation&#34;: &#34;bicubic&#34;
            }

    Returns:
        Dict: Raster specifications, None if VECTOR pyramid
    &#34;&#34;&#34;
    return self.__raster_specifications</code></pre>
</details>
</dd>
<dt id="rok4.pyramid.Pyramid.serializable"><code class="name">prop <span class="ident">serializable</span> : Dict[~KT, ~VT]</code></dt>
<dd>
<div class="desc"><p>Get the dict version of the pyramid object, descriptor compliant</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict</code></dt>
<dd>descriptor structured object description</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def serializable(self) -&gt; Dict:
    &#34;&#34;&#34;Get the dict version of the pyramid object, descriptor compliant

    Returns:
        Dict: descriptor structured object description
    &#34;&#34;&#34;

    serialization = {&#34;tile_matrix_set&#34;: self.__tms.name, &#34;format&#34;: self.__format}

    serialization[&#34;levels&#34;] = []
    sorted_levels = sorted(
        self.__levels.values(), key=lambda level: level.resolution, reverse=True
    )

    for level in sorted_levels:
        serialization[&#34;levels&#34;].append(level.serializable)

    if self.type == PyramidType.RASTER:
        serialization[&#34;raster_specifications&#34;] = self.__raster_specifications

    if self.__masks:
        serialization[&#34;mask_format&#34;] = &#34;TIFF_ZIP_UINT8&#34;

    return serialization</code></pre>
</details>
</dd>
<dt id="rok4.pyramid.Pyramid.size"><code class="name">prop <span class="ident">size</span> : int</code></dt>
<dd>
<div class="desc"><p>Get the size of the pyramid</p>
<h2 id="examples">Examples</h2>
<p>from rok4.pyramid import Pyramid</p>
<p>try:
pyramid = Pyramid.from_descriptor("s3://bucket_name/path/to/descriptor.json")
size = pyramid.size()</p>
<p>except Exception as e:
print("Cannot load the pyramid from its descriptor and get his size")</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>size of the pyramid</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self) -&gt; int:
    &#34;&#34;&#34;Get the size of the pyramid

    Examples:

            from rok4.pyramid import Pyramid

            try:
                pyramid = Pyramid.from_descriptor(&#34;s3://bucket_name/path/to/descriptor.json&#34;)
                size = pyramid.size()

            except Exception as e:
                print(&#34;Cannot load the pyramid from its descriptor and get his size&#34;)

    Returns:
        int: size of the pyramid
    &#34;&#34;&#34;

    if not hasattr(self, &#34;_Pyramid__size&#34;):
        self.__size = size_path(
            get_path_from_infos(self.__storage[&#34;type&#34;], self.__storage[&#34;root&#34;], self.__name)
        )

    return self.__size</code></pre>
</details>
</dd>
<dt id="rok4.pyramid.Pyramid.storage_depth"><code class="name">prop <span class="ident">storage_depth</span> : int</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def storage_depth(self) -&gt; int:
    return self.__storage.get(&#34;depth&#34;, None)</code></pre>
</details>
</dd>
<dt id="rok4.pyramid.Pyramid.storage_root"><code class="name">prop <span class="ident">storage_root</span> : str</code></dt>
<dd>
<div class="desc"><p>Get the pyramid's storage root.</p>
<p>If storage is S3, the used cluster is removed.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Pyramid's storage root</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def storage_root(self) -&gt; str:
    &#34;&#34;&#34;Get the pyramid&#39;s storage root.

    If storage is S3, the used cluster is removed.

    Returns:
        str: Pyramid&#39;s storage root
    &#34;&#34;&#34;

    return self.__storage[&#34;root&#34;].split(&#34;@&#34;, 1)[
        0
    ]  # Suppression de l&#39;éventuel hôte de spécification du cluster S3</code></pre>
</details>
</dd>
<dt id="rok4.pyramid.Pyramid.storage_s3_cluster"><code class="name">prop <span class="ident">storage_s3_cluster</span> : str</code></dt>
<dd>
<div class="desc"><p>Get the pyramid's storage S3 cluster (host name)</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>the host if known, None if the default one have to be used or if storage is not S3</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def storage_s3_cluster(self) -&gt; str:
    &#34;&#34;&#34;Get the pyramid&#39;s storage S3 cluster (host name)

    Returns:
        str: the host if known, None if the default one have to be used or if storage is not S3
    &#34;&#34;&#34;
    if self.__storage[&#34;type&#34;] == StorageType.S3:
        try:
            return self.__storage[&#34;root&#34;].split(&#34;@&#34;)[1]
        except IndexError:
            return None
    else:
        return None</code></pre>
</details>
</dd>
<dt id="rok4.pyramid.Pyramid.storage_type"><code class="name">prop <span class="ident">storage_type</span> : <a title="rok4.enums.StorageType" href="enums.html#rok4.enums.StorageType">StorageType</a></code></dt>
<dd>
<div class="desc"><p>Get the storage type</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>StorageType</code></dt>
<dd>FILE, S3 or CEPH</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def storage_type(self) -&gt; StorageType:
    &#34;&#34;&#34;Get the storage type

    Returns:
        StorageType: FILE, S3 or CEPH
    &#34;&#34;&#34;
    return self.__storage[&#34;type&#34;]</code></pre>
</details>
</dd>
<dt id="rok4.pyramid.Pyramid.tile_extension"><code class="name">prop <span class="ident">tile_extension</span> : str</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def tile_extension(self) -&gt; str:
    if self.__format in [
        &#34;TIFF_RAW_UINT8&#34;,
        &#34;TIFF_LZW_UINT8&#34;,
        &#34;TIFF_ZIP_UINT8&#34;,
        &#34;TIFF_PKB_UINT8&#34;,
        &#34;TIFF_RAW_FLOAT32&#34;,
        &#34;TIFF_LZW_FLOAT32&#34;,
        &#34;TIFF_ZIP_FLOAT32&#34;,
        &#34;TIFF_PKB_FLOAT32&#34;,
    ]:
        return &#34;tif&#34;
    elif self.__format in [&#34;TIFF_JPG_UINT8&#34;, &#34;TIFF_JPG90_UINT8&#34;]:
        return &#34;jpg&#34;
    elif self.__format == &#34;TIFF_PNG_UINT8&#34;:
        return &#34;png&#34;
    elif self.__format == &#34;TIFF_PBF_MVT&#34;:
        return &#34;pbf&#34;
    else:
        raise Exception(
            f&#34;Unknown pyramid&#39;s format ({self.__format}), cannot return the tile extension&#34;
        )</code></pre>
</details>
</dd>
<dt id="rok4.pyramid.Pyramid.tms"><code class="name">prop <span class="ident">tms</span> : <a title="rok4.tile_matrix_set.TileMatrixSet" href="tile_matrix_set.html#rok4.tile_matrix_set.TileMatrixSet">TileMatrixSet</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def tms(self) -&gt; TileMatrixSet:
    return self.__tms</code></pre>
</details>
</dd>
<dt id="rok4.pyramid.Pyramid.top_level"><code class="name">prop <span class="ident">top_level</span> : <a title="rok4.pyramid.Level" href="#rok4.pyramid.Level">Level</a></code></dt>
<dd>
<div class="desc"><p>Get the low resolution level in the pyramid</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="rok4.pyramid.Level" href="#rok4.pyramid.Level">Level</a></code></dt>
<dd>the top level</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def top_level(self) -&gt; &#34;Level&#34;:
    &#34;&#34;&#34;Get the low resolution level in the pyramid

    Returns:
        Level: the top level
    &#34;&#34;&#34;
    return sorted(self.__levels.values(), key=lambda level: level.resolution)[-1]</code></pre>
</details>
</dd>
<dt id="rok4.pyramid.Pyramid.type"><code class="name">prop <span class="ident">type</span> : <a title="rok4.enums.PyramidType" href="enums.html#rok4.enums.PyramidType">PyramidType</a></code></dt>
<dd>
<div class="desc"><p>Get the pyramid's type (RASTER or VECTOR) from its format</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>PyramidType</code></dt>
<dd>RASTER or VECTOR</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def type(self) -&gt; PyramidType:
    &#34;&#34;&#34;Get the pyramid&#39;s type (RASTER or VECTOR) from its format

    Returns:
        PyramidType: RASTER or VECTOR
    &#34;&#34;&#34;
    if self.__format == &#34;TIFF_PBF_MVT&#34;:
        return PyramidType.VECTOR
    else:
        return PyramidType.RASTER</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="rok4.pyramid.Pyramid.add_level"><code class="name flex">
<span>def <span class="ident">add_level</span></span>(<span>self, level_id: str, tiles_per_width: int, tiles_per_height: int, tile_limits: Dict[str, int]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Add a level in the description of the pyramid</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>level_id</code></strong></dt>
<dd>Level identifier</dd>
</dl>
<p>tiles_per_width : Number of tiles in width by slab
tiles_per_height : Number of tiles in height by slab
tile_limits : Minimum and maximum tiles' columns and rows of pyramid's content</p></div>
</dd>
<dt id="rok4.pyramid.Pyramid.delete_level"><code class="name flex">
<span>def <span class="ident">delete_level</span></span>(<span>self, level_id: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Delete the given level in the description of the pyramid</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>level_id</code></strong></dt>
<dd>Level identifier</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>Exception</code></dt>
<dd>Cannot find level</dd>
</dl></div>
</dd>
<dt id="rok4.pyramid.Pyramid.get_infos_from_slab_path"><code class="name flex">
<span>def <span class="ident">get_infos_from_slab_path</span></span>(<span>self, path: str) ‑> Tuple[<a title="rok4.enums.SlabType" href="enums.html#rok4.enums.SlabType">SlabType</a>, str, int, int]</span>
</code></dt>
<dd>
<div class="desc"><p>Get the slab's indices from its storage path</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>Slab's storage path</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>FILE stored pyramid</p>
<pre><code>from rok4.pyramid import Pyramid

try:
    pyramid = Pyramid.from_descriptor("/path/to/descriptor.json")
    slab_type, level, column, row = self.get_infos_from_slab_path("DATA/12/00/4A/F7.tif")
    # (SlabType.DATA, "12", 159, 367)
except Exception as e:
    print("Cannot load the pyramid from its descriptor and convert a slab path")
</code></pre>
<p>S3 stored pyramid</p>
<pre><code>from rok4.pyramid import Pyramid

try:
    pyramid = Pyramid.from_descriptor("s3://bucket_name/path/to/pyramid.json")
    slab_type, level, column, row = self.get_infos_from_slab_path("s3://bucket_name/path/to/pyramid/MASK_15_9164_5846")
    # (SlabType.MASK, "15", 9164, 5846)
except Exception as e:
    print("Cannot load the pyramid from its descriptor and convert a slab path")
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tuple[SlabType, str, int, int]</code></dt>
<dd>Slab's type (DATA or MASK), level identifier, slab's column and slab's row</dd>
</dl></div>
</dd>
<dt id="rok4.pyramid.Pyramid.get_level"><code class="name flex">
<span>def <span class="ident">get_level</span></span>(<span>self, level_id: str) ‑> <a title="rok4.pyramid.Level" href="#rok4.pyramid.Level">Level</a></span>
</code></dt>
<dd>
<div class="desc"><p>Get one level according to its identifier</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>level_id</code></strong></dt>
<dd>Level identifier</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The corresponding pyramid's level, None if not present</p></div>
</dd>
<dt id="rok4.pyramid.Pyramid.get_levels"><code class="name flex">
<span>def <span class="ident">get_levels</span></span>(<span>self, bottom_id: str = None, top_id: str = None) ‑> List[<a title="rok4.pyramid.Level" href="#rok4.pyramid.Level">Level</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Get sorted levels in the provided range from bottom to top</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>bottom_id</code></strong> :&ensp;<code>str, optionnal</code></dt>
<dd>specific bottom level id. Defaults to None.</dd>
<dt><strong><code>top_id</code></strong> :&ensp;<code>str, optionnal</code></dt>
<dd>specific top level id. Defaults to None.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>Exception</code></dt>
<dd>Provided levels are not consistent (bottom &gt; top or not in the pyramid)</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>All levels</p>
<pre><code>from rok4.pyramid import Pyramid

try:
    pyramid = Pyramid.from_descriptor("s3://bucket_name/path/to/descriptor.json")
    levels = pyramid.get_levels()

except Exception as e:
    print("Cannot load the pyramid from its descriptor and get levels")
</code></pre>
<p>From pyramid's bottom to provided top (level 5)</p>
<pre><code>from rok4.pyramid import Pyramid

try:
    pyramid = Pyramid.from_descriptor("s3://bucket_name/path/to/descriptor.json")
    levels = pyramid.get_levels(None, "5")

except Exception as e:
    print("Cannot load the pyramid from its descriptor and get levels")
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[<a title="rok4.pyramid.Level" href="#rok4.pyramid.Level">Level</a>]</code></dt>
<dd>asked sorted levels</dd>
</dl></div>
</dd>
<dt id="rok4.pyramid.Pyramid.get_slab_path_from_infos"><code class="name flex">
<span>def <span class="ident">get_slab_path_from_infos</span></span>(<span>self, slab_type: <a title="rok4.enums.SlabType" href="enums.html#rok4.enums.SlabType">SlabType</a>, level: str, column: int, row: int, full: bool = True) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Get slab's storage path from the indices</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>slab_type</code></strong> :&ensp;<code>SlabType</code></dt>
<dd>DATA or MASK</dd>
<dt><strong><code>level</code></strong> :&ensp;<code>str</code></dt>
<dd>Level identifier</dd>
<dt><strong><code>column</code></strong> :&ensp;<code>int</code></dt>
<dd>Slab's column</dd>
<dt><strong><code>row</code></strong> :&ensp;<code>int</code></dt>
<dd>Slab's row</dd>
<dt><strong><code>full</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Full path or just relative path from pyramid storage root. Defaults to True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Absolute or relative slab's storage path</dd>
</dl></div>
</dd>
<dt id="rok4.pyramid.Pyramid.get_tile_data_binary"><code class="name flex">
<span>def <span class="ident">get_tile_data_binary</span></span>(<span>self, level: str, column: int, row: int) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Get a pyramid's tile as binary string</p>
<p>To get a tile, 3 steps :
* calculate slab path from tile index
* read slab index to get offsets and sizes of slab's tiles
* read the tile into the slab</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>level</code></strong> :&ensp;<code>str</code></dt>
<dd>Tile's level</dd>
<dt><strong><code>column</code></strong> :&ensp;<code>int</code></dt>
<dd>Tile's column</dd>
<dt><strong><code>row</code></strong> :&ensp;<code>int</code></dt>
<dd>Tile's row</dd>
</dl>
<h2 id="limitations">Limitations</h2>
<p>Pyramids with one-tile slab are not handled</p>
<h2 id="examples">Examples</h2>
<p>FILE stored raster pyramid, to extract a tile containing a point and save it as independent image</p>
<pre><code>from rok4.pyramid import Pyramid

try:
    pyramid = Pyramid.from_descriptor("/data/pyramids/SCAN1000.json")
    level, col, row, pcol, prow = pyramid.get_tile_indices(992904.46, 6733643.15, "9", srs = "IGNF:LAMB93")
    data = pyramid.get_tile_data_binary(level, col, row)

    if data is None:
        print("No data")
    else:
        tile_name = f"tile_{level}_{col}_{row}.{pyramid.tile_extension}"
        with open(tile_name, "wb") as image:
            image.write(data)
        print (f"Tile written in {tile_name}")

except Exception as e:
    print("Cannot save a pyramid's tile : {e}")
</code></pre>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>Exception</code></dt>
<dd>Level not found in the pyramid</dd>
<dt><code>NotImplementedError</code></dt>
<dd>Pyramid owns one-tile slabs</dd>
<dt><code>MissingEnvironmentError</code></dt>
<dd>Missing object storage informations</dd>
<dt><code>StorageError</code></dt>
<dd>Storage read issue</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>data, as binary string, None if no data</dd>
</dl></div>
</dd>
<dt id="rok4.pyramid.Pyramid.get_tile_data_raster"><code class="name flex">
<span>def <span class="ident">get_tile_data_raster</span></span>(<span>self, level: str, column: int, row: int) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Get a raster pyramid's tile as 3-dimension numpy ndarray</p>
<p>First dimension is the row, second one is column, third one is band.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>level</code></strong> :&ensp;<code>str</code></dt>
<dd>Tile's level</dd>
<dt><strong><code>column</code></strong> :&ensp;<code>int</code></dt>
<dd>Tile's column</dd>
<dt><strong><code>row</code></strong> :&ensp;<code>int</code></dt>
<dd>Tile's row</dd>
</dl>
<h2 id="limitations">Limitations</h2>
<p>Packbits (pyramid formats TIFF_PKB_FLOAT32 and TIFF_PKB_UINT8) and LZW (pyramid formats TIFF_LZW_FLOAT32 and TIFF_LZW_UINT8) compressions are not handled.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>Exception</code></dt>
<dd>Cannot get raster data for a vector pyramid</dd>
<dt><code>Exception</code></dt>
<dd>Level not found in the pyramid</dd>
<dt><code>NotImplementedError</code></dt>
<dd>Pyramid owns one-tile slabs</dd>
<dt><code>NotImplementedError</code></dt>
<dd>Raster pyramid format not handled</dd>
<dt><code>MissingEnvironmentError</code></dt>
<dd>Missing object storage informations</dd>
<dt><code>StorageError</code></dt>
<dd>Storage read issue</dd>
<dt><code>FormatError</code></dt>
<dd>Cannot decode tile</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>FILE stored DTM (raster) pyramid, to get the altitude value at a point in the best level</p>
<pre><code>from rok4.pyramid import Pyramid

try:
    pyramid = Pyramid.from_descriptor("/data/pyramids/RGEALTI.json")
    level, col, row, pcol, prow = pyramid.get_tile_indices(44, 5, srs = "EPSG:4326")
    data = pyramid.get_tile_data_raster(level, col, row)

    if data is None:
        print("No data")
    else:
        print(data[prow][pcol])

except Exception as e:
    print("Cannot get a pyramid's pixel value : {e}")
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>data, as numpy array, None if no data</dd>
</dl></div>
</dd>
<dt id="rok4.pyramid.Pyramid.get_tile_data_vector"><code class="name flex">
<span>def <span class="ident">get_tile_data_vector</span></span>(<span>self, level: str, column: int, row: int) ‑> Dict[~KT, ~VT]</span>
</code></dt>
<dd>
<div class="desc"><p>Get a vector pyramid's tile as GeoJSON dictionnary</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>level</code></strong> :&ensp;<code>str</code></dt>
<dd>Tile's level</dd>
<dt><strong><code>column</code></strong> :&ensp;<code>int</code></dt>
<dd>Tile's column</dd>
<dt><strong><code>row</code></strong> :&ensp;<code>int</code></dt>
<dd>Tile's row</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>Exception</code></dt>
<dd>Cannot get vector data for a raster pyramid</dd>
<dt><code>Exception</code></dt>
<dd>Level not found in the pyramid</dd>
<dt><code>NotImplementedError</code></dt>
<dd>Pyramid owns one-tile slabs</dd>
<dt><code>NotImplementedError</code></dt>
<dd>Vector pyramid format not handled</dd>
<dt><code>MissingEnvironmentError</code></dt>
<dd>Missing object storage informations</dd>
<dt><code>StorageError</code></dt>
<dd>Storage read issue</dd>
<dt><code>FormatError</code></dt>
<dd>Cannot decode tile</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>S3 stored vector pyramid, to print a tile as GeoJSON</p>
<pre><code>from rok4.pyramid import Pyramid

import json

try:
    pyramid = Pyramid.from_descriptor("s3://pyramids/vectors/BDTOPO.json")
    level, col, row, pcol, prow = pyramid.get_tile_indices(40.325, 3.123, srs = "EPSG:4326")
    data = pyramid.get_tile_data_vector(level, col, row)

    if data is None:
        print("No data")
    else:
        print(json.dumps(data))

except Exception as e:
    print("Cannot print a vector pyramid's tile as GeoJSON : {e}")
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>data, as GeoJSON dictionnary. None if no data</dd>
</dl></div>
</dd>
<dt id="rok4.pyramid.Pyramid.get_tile_indices"><code class="name flex">
<span>def <span class="ident">get_tile_indices</span></span>(<span>self, x: float, y: float, level: str = None, **kwargs) ‑> Tuple[str, int, int, int, int]</span>
</code></dt>
<dd>
<div class="desc"><p>Get pyramid's tile and pixel indices from point's coordinates</p>
<p>Used coordinates system have to be the pyramid one. If EPSG:4326, x is latitude and y longitude.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>point's x</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>point's y</dd>
<dt><strong><code>level</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Pyramid's level to take into account, the bottom one if None . Defaults to None.</dd>
<dt><strong><code>**srs</code></strong> :&ensp;<code>string</code></dt>
<dd>spatial reference system of provided coordinates, with authority and code (same as the pyramid's one if not provided)</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>Exception</code></dt>
<dd>Cannot find level to calculate indices</dd>
<dt><code>RuntimeError</code></dt>
<dd>Provided SRS is invalid for OSR</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>FILE stored DTM (raster) pyramid, to get the altitude value at a point in the best level</p>
<pre><code>from rok4.pyramid import Pyramid

try:
    pyramid = Pyramid.from_descriptor("/data/pyramids/RGEALTI.json")
    level, col, row, pcol, prow = pyramid.get_tile_indices(44, 5, srs = "EPSG:4326")
    data = pyramid.get_tile_data_raster(level, col, row)

    if data is None:
        print("No data")
    else:
        print(data[prow][pcol])

except Exception as e:
    print("Cannot get a pyramid's pixel value : {e}")
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tuple[str, int, int, int, int]</code></dt>
<dd>Level identifier, tile's column, tile's row, pixel's (in the tile) column, pixel's row</dd>
</dl></div>
</dd>
<dt id="rok4.pyramid.Pyramid.list_generator"><code class="name flex">
<span>def <span class="ident">list_generator</span></span>(<span>self, level_id: str = None) ‑> Iterator[Tuple[Tuple[<a title="rok4.enums.SlabType" href="enums.html#rok4.enums.SlabType">SlabType</a>, str, int, int], Dict[~KT, ~VT]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Get list content</p>
<p>List is copied as temporary file, roots are read and informations about each slab is returned. If list is already loaded, we yield the cached content
Args :
level_id (str) : id of the level for load only one level</p>
<h2 id="examples">Examples</h2>
<p>S3 stored descriptor</p>
<pre><code>from rok4.pyramid import Pyramid

try:
    pyramid = Pyramid.from_descriptor("s3://bucket_name/path/to/descriptor.json")

    for (slab_type, level, column, row), infos in pyramid.list_generator():
        print(infos)

except Exception as e:
    print("Cannot load the pyramid from its descriptor and read the list")
</code></pre>
<h2 id="yields">Yields</h2>
<dl>
<dt><code>Iterator[Tuple[Tuple[SlabType,str,int,int], Dict]]</code></dt>
<dd>Slab indices and storage informations</dd>
</dl>
<p>Value example:</p>
<pre><code>(
    (&lt;SlabType.DATA: 'DATA'&gt;, '18', 5424, 7526),
    {
        'link': False,
        'md5': None,
        'root': 'pyramids@localhost:9000/LIMADM',
        'slab': 'DATA_18_5424_7526'
    }
)
</code></pre>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>StorageError</code></dt>
<dd>Unhandled pyramid storage to copy list</dd>
<dt><code>MissingEnvironmentError</code></dt>
<dd>Missing object storage informations</dd>
</dl></div>
</dd>
<dt id="rok4.pyramid.Pyramid.load_list"><code class="name flex">
<span>def <span class="ident">load_list</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Load list content and cache it</p>
<p>If list is already loaded, nothing done</p></div>
</dd>
<dt id="rok4.pyramid.Pyramid.write_descriptor"><code class="name flex">
<span>def <span class="ident">write_descriptor</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Write the pyramid's descriptor to the final location (in the pyramid's storage root)</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="rok4" href="index.html">rok4</a></code></li>
</ul>
</li>
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="">
<li><code><a title="rok4.pyramid.ROK4_IMAGE_HEADER_SIZE" href="#rok4.pyramid.ROK4_IMAGE_HEADER_SIZE">ROK4_IMAGE_HEADER_SIZE</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="rok4.pyramid.b36_number_decode" href="#rok4.pyramid.b36_number_decode">b36_number_decode</a></code></li>
<li><code><a title="rok4.pyramid.b36_number_encode" href="#rok4.pyramid.b36_number_encode">b36_number_encode</a></code></li>
<li><code><a title="rok4.pyramid.b36_path_decode" href="#rok4.pyramid.b36_path_decode">b36_path_decode</a></code></li>
<li><code><a title="rok4.pyramid.b36_path_encode" href="#rok4.pyramid.b36_path_encode">b36_path_encode</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="rok4.pyramid.Level" href="#rok4.pyramid.Level">Level</a></code></h4>
<ul class="">
<li><code><a title="rok4.pyramid.Level.bbox" href="#rok4.pyramid.Level.bbox">bbox</a></code></li>
<li><code><a title="rok4.pyramid.Level.from_descriptor" href="#rok4.pyramid.Level.from_descriptor">from_descriptor</a></code></li>
<li><code><a title="rok4.pyramid.Level.from_other" href="#rok4.pyramid.Level.from_other">from_other</a></code></li>
<li><code><a title="rok4.pyramid.Level.id" href="#rok4.pyramid.Level.id">id</a></code></li>
<li><code><a title="rok4.pyramid.Level.is_in_limits" href="#rok4.pyramid.Level.is_in_limits">is_in_limits</a></code></li>
<li><code><a title="rok4.pyramid.Level.resolution" href="#rok4.pyramid.Level.resolution">resolution</a></code></li>
<li><code><a title="rok4.pyramid.Level.serializable" href="#rok4.pyramid.Level.serializable">serializable</a></code></li>
<li><code><a title="rok4.pyramid.Level.set_limits_from_bbox" href="#rok4.pyramid.Level.set_limits_from_bbox">set_limits_from_bbox</a></code></li>
<li><code><a title="rok4.pyramid.Level.slab_height" href="#rok4.pyramid.Level.slab_height">slab_height</a></code></li>
<li><code><a title="rok4.pyramid.Level.slab_width" href="#rok4.pyramid.Level.slab_width">slab_width</a></code></li>
<li><code><a title="rok4.pyramid.Level.tile_limits" href="#rok4.pyramid.Level.tile_limits">tile_limits</a></code></li>
<li><code><a title="rok4.pyramid.Level.tile_matrix" href="#rok4.pyramid.Level.tile_matrix">tile_matrix</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="rok4.pyramid.Pyramid" href="#rok4.pyramid.Pyramid">Pyramid</a></code></h4>
<ul class="">
<li><code><a title="rok4.pyramid.Pyramid.add_level" href="#rok4.pyramid.Pyramid.add_level">add_level</a></code></li>
<li><code><a title="rok4.pyramid.Pyramid.bottom_level" href="#rok4.pyramid.Pyramid.bottom_level">bottom_level</a></code></li>
<li><code><a title="rok4.pyramid.Pyramid.channels" href="#rok4.pyramid.Pyramid.channels">channels</a></code></li>
<li><code><a title="rok4.pyramid.Pyramid.delete_level" href="#rok4.pyramid.Pyramid.delete_level">delete_level</a></code></li>
<li><code><a title="rok4.pyramid.Pyramid.descriptor" href="#rok4.pyramid.Pyramid.descriptor">descriptor</a></code></li>
<li><code><a title="rok4.pyramid.Pyramid.format" href="#rok4.pyramid.Pyramid.format">format</a></code></li>
<li><code><a title="rok4.pyramid.Pyramid.from_descriptor" href="#rok4.pyramid.Pyramid.from_descriptor">from_descriptor</a></code></li>
<li><code><a title="rok4.pyramid.Pyramid.from_other" href="#rok4.pyramid.Pyramid.from_other">from_other</a></code></li>
<li><code><a title="rok4.pyramid.Pyramid.get_infos_from_slab_path" href="#rok4.pyramid.Pyramid.get_infos_from_slab_path">get_infos_from_slab_path</a></code></li>
<li><code><a title="rok4.pyramid.Pyramid.get_level" href="#rok4.pyramid.Pyramid.get_level">get_level</a></code></li>
<li><code><a title="rok4.pyramid.Pyramid.get_levels" href="#rok4.pyramid.Pyramid.get_levels">get_levels</a></code></li>
<li><code><a title="rok4.pyramid.Pyramid.get_slab_path_from_infos" href="#rok4.pyramid.Pyramid.get_slab_path_from_infos">get_slab_path_from_infos</a></code></li>
<li><code><a title="rok4.pyramid.Pyramid.get_tile_data_binary" href="#rok4.pyramid.Pyramid.get_tile_data_binary">get_tile_data_binary</a></code></li>
<li><code><a title="rok4.pyramid.Pyramid.get_tile_data_raster" href="#rok4.pyramid.Pyramid.get_tile_data_raster">get_tile_data_raster</a></code></li>
<li><code><a title="rok4.pyramid.Pyramid.get_tile_data_vector" href="#rok4.pyramid.Pyramid.get_tile_data_vector">get_tile_data_vector</a></code></li>
<li><code><a title="rok4.pyramid.Pyramid.get_tile_indices" href="#rok4.pyramid.Pyramid.get_tile_indices">get_tile_indices</a></code></li>
<li><code><a title="rok4.pyramid.Pyramid.list" href="#rok4.pyramid.Pyramid.list">list</a></code></li>
<li><code><a title="rok4.pyramid.Pyramid.list_generator" href="#rok4.pyramid.Pyramid.list_generator">list_generator</a></code></li>
<li><code><a title="rok4.pyramid.Pyramid.load_list" href="#rok4.pyramid.Pyramid.load_list">load_list</a></code></li>
<li><code><a title="rok4.pyramid.Pyramid.name" href="#rok4.pyramid.Pyramid.name">name</a></code></li>
<li><code><a title="rok4.pyramid.Pyramid.own_masks" href="#rok4.pyramid.Pyramid.own_masks">own_masks</a></code></li>
<li><code><a title="rok4.pyramid.Pyramid.raster_specifications" href="#rok4.pyramid.Pyramid.raster_specifications">raster_specifications</a></code></li>
<li><code><a title="rok4.pyramid.Pyramid.serializable" href="#rok4.pyramid.Pyramid.serializable">serializable</a></code></li>
<li><code><a title="rok4.pyramid.Pyramid.size" href="#rok4.pyramid.Pyramid.size">size</a></code></li>
<li><code><a title="rok4.pyramid.Pyramid.storage_depth" href="#rok4.pyramid.Pyramid.storage_depth">storage_depth</a></code></li>
<li><code><a title="rok4.pyramid.Pyramid.storage_root" href="#rok4.pyramid.Pyramid.storage_root">storage_root</a></code></li>
<li><code><a title="rok4.pyramid.Pyramid.storage_s3_cluster" href="#rok4.pyramid.Pyramid.storage_s3_cluster">storage_s3_cluster</a></code></li>
<li><code><a title="rok4.pyramid.Pyramid.storage_type" href="#rok4.pyramid.Pyramid.storage_type">storage_type</a></code></li>
<li><code><a title="rok4.pyramid.Pyramid.tile_extension" href="#rok4.pyramid.Pyramid.tile_extension">tile_extension</a></code></li>
<li><code><a title="rok4.pyramid.Pyramid.tms" href="#rok4.pyramid.Pyramid.tms">tms</a></code></li>
<li><code><a title="rok4.pyramid.Pyramid.top_level" href="#rok4.pyramid.Pyramid.top_level">top_level</a></code></li>
<li><code><a title="rok4.pyramid.Pyramid.type" href="#rok4.pyramid.Pyramid.type">type</a></code></li>
<li><code><a title="rok4.pyramid.Pyramid.write_descriptor" href="#rok4.pyramid.Pyramid.write_descriptor">write_descriptor</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.0</a>.</p>
</footer>
</body>
</html>
